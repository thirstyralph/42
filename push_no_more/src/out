/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cost.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 04:12:19 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/07 22:14:13 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

int	optimised_cost(int top_a, int top_b, int target_a, int target_b)
{
	int	middle_a;
	int	middle_b;
	int	cost_a;
	int	cost_b;
	int	cost_total;

	middle_a = median(top_a, target_a);
	middle_b = median(top_b, target_b);
	cost_a = single_cost(target_a, top_a, middle_a);
	cost_b = single_cost(target_b, top_b, middle_b);
	if ((middle_a == 1 && middle_b == 1) || (middle_a == 2 && middle_b == 2))
		cost_total = max(cost_a, cost_b); 
	else
		cost_total = cost_b + cost_a;
	return (cost_total);
}

/*
	must take stacks a and b
	must return a cost array.
*/
int	*calculate_cost(t_stack a, t_stack b)
{
	int	i;
	int	*result;
	int	current_target;

	result = malloc(sizeof(int) * (b.top + 1));
	if (!result)
		return (NULL);
	i = 0;
	while (i <= b.top)
	{
		current_target = target(a, b.arr[i]);
		result[i] = optimised_cost(a.top, b.top, current_target, i);
		i++;
	}
		return (result);
}
#include "./../push_swap.h"

/*
	calculates the necesary actions to move given position of the stack a
	 to the top and writes them into the movement structure accordingly
	t_mo *seq: pointer to the sequence array.
	int middle: median of the stack tha where our target is located
				1 = below the median
				2 = above the median
	top: top value of the stack
	pos: position of the number we want to move to the top
*/
void	determine_single_ops_a(t_mov *seq, int middle, int top, int pos)
{
	if (middle == 1)
		seq->ra = top - pos;
	else if (middle == 2)
		seq->rra = pos;
}

/*
	calculates the necesary actions to move given position of the stack b
	 to the top and writes them into the movement structure accordingly
	t_mov *seq: pointer to the sequence array.
	int middle: median of the stack tha where our target is located
				1 = below the median
				2 = above the median
	top: top value of the stack
	pos: position of the number we want to move to the top
*/
void	determine_single_ops_b(t_mov *seq, int middle, int top, int pos)
{
	if (middle == 1)
		seq->rb = top - pos;
	else if (middle == 2)
		seq->rrb = pos;
}

/*
	given single operations, (ra & rb or rra & rrb), edits the movement 
	structure to reduce the number of operations
*/
void	calculate_single_optimization(int *a, int *b, int *double_op)
{
	if (*a == *b)
	{
		*double_op = *a;
		*a = 0;
		*b = 0;
	}
	else if (*a > *b)
	{
		*double_op = *b;
		*a = *a - *b;
		*b = 0;
	}
	else if (*b > *a)
	{
		*double_op = *a;
		*b = *b - *a;
		*a = 0;
	}
}

void	optimise(t_mov *seq)
{
	if (seq->rb != 0 && seq->ra != 0)
		calculate_single_optimization(&seq->ra, &seq->rb, &seq->rr);
	else if (seq->rrb != 0 && seq->rra != 0)
		calculate_single_optimization(&seq->rra, &seq->rrb, &seq->rrr);
}

/*
	when given a position in b and  a target postion in a
	it retuns the number of necessary operations needed to 
	move b into a
void	determine_single_ops_b(t_mov *seq, int middle, int top, int pos)
*/
t_mov	calculate_movs(int top_a, int top_b, int target_a, int target_b)
{
	t_mov	seq;
	int		middle_a;
	int		middle_b;

	seq.ra = 0;
	seq.rra = 0;
	seq.rb = 0;
	seq.rrb = 0;
	seq.rrr = 0;
	seq.rr = 0;
	middle_a = median(top_a, target_a);
	middle_b = median(top_b, target_b);
	determine_single_ops_a(&seq, middle_a, top_a, target_a);
	determine_single_ops_b(&seq, middle_b, top_b, target_b);
	optimise(&seq);
	return (seq);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   double_operations.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 03:03:20 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 03:08:50 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

void	double_rotate(t_stack *a, t_stack *b)
{
	_rotate(a);
	_rotate(b);
	ft_printf("rr\n");
}

void	double_swap(t_stack *a, t_stack *b)
{
	_swap(a);
	_swap(b);
	ft_printf("ss\n");
}

void	double_reverse(t_stack *a, t_stack *b)
{
	_reverse_rotate(a);
	_reverse_rotate(b);
	ft_printf("rrr\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operations.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 01:52:14 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 01:54:26 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	_swap(t_stack *stack)
{
	int	tmp;
	int	top;

	top = stack->top;
	tmp = stack->arr[top];
	stack->arr[top] = stack->arr[top - 1];
	stack->arr[top - 1] = tmp;
}

void	_rotate(t_stack *stack)
{
	int	tmp;

	if (stack->top > 0)
	{
		tmp = stack->arr[stack->top];
		ft_memmove(&stack->arr[1], &stack->arr[0], stack->top * sizeof(int));
		stack->arr[0] = tmp;
	}
}

void	_reverse_rotate(t_stack *stack)
{
	int	tmp;

	if (stack->top > 0)
	{
	tmp = stack->arr[0];
	ft_memmove(&stack->arr[0], &stack->arr[1], stack->top * sizeof(int));
	stack->arr[stack->top] = tmp;
	}
}

void	_push(t_stack *target, t_stack *source)
{
	if (target->top < target->max_size && source->top >= 0)
	{
		target->top++;
		target->arr[target->top] = source->arr[source->top];
		source->top--;
	}
	else
		return ;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_empty.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/07 21:51:32 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/07 21:51:49 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_sorted.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 01:09:43 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 04:02:47 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

int	is_sorted(t_stack stack)
{
	int	i;

	i = stack.top;
	while (i > 1)
	{
		if (stack.arr[i] > stack.arr[i - 1])
			return (0);
		i--;
	}
	return (1);
}
#include "./../push_swap.h"

int	main(int argc, char *argv[])
{
	// declara las estructuras
	t_stack	a;
	t_stack	b;
	// t_stack a.arr = parse
	a.top = argc - 2;
	a.arr = parse(argc, argv);
	a.name = 'a';
	b.name = 'b';
	a.max_size = argc - 2;
	b.max_size = argc - 2;
	// malloc b.arr
	if (a.top == 1)
		sort_two(&a);
	else if (a.top == 2)
		sort_three(&a);
	else
	{
		b.arr = malloc(sizeof(int) * (argc - 1));
		if (!b.arr)
			return (1);
		b.top = -1;
		turk(&a, &b);
		free(b.arr);
	}
	free(a.arr);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operations.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 01:52:14 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 01:54:26 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	swap(t_stack *stack)
{
	_swap(stack);
	ft_printf("s%c\n", stack->name);
}

void	rotate(t_stack *stack)
{
	_rotate(stack);
	ft_printf("r%c\n", stack->name);
}

void	reverse_rotate(t_stack *stack)
{
	_reverse_rotate(stack);
	ft_printf("rr%c\n", stack->name);
}

void	push(t_stack *target, t_stack *source)
{
	_push(target, source);
	ft_printf("p%c\n", target->name);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 00:38:06 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/08 00:45:39 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

void	error(void)
{
	ft_printf("Error\n");
	exit(1);
}

int	*arrtoi(int argc, char *argv[])
{
	int	i;
	int	*result;

	result = malloc(sizeof(int) * (argc - 1));
	if (!result)
		return (NULL);
	i = 0;
	while (i < argc - 1)
	{
		result[argc - 2 - i] = ft_atoi(argv[i + 1]);
		i++;
	}
	return (result);
}

/*
	0 = fail, there a repeated numbers
	1 = pass, no repetition
*/
int	check_repetition(int top, int *tab)
{
	int	i;
	int	j;

	i = 0;
	while (i <= top)
	{
		j = 0;
		while (j <= top)
		{
			if (j != i && tab[i] == tab[j])
				return (0);
			j++;
		}
		i++;
	}
	return (1);
}

int	*parse(int argc, char *argv[])
{
	int	*tmp;

	if (argc <= 2)
		error();
	tmp = arrtoi(argc, argv);
	if (check_repetition(argc - 2, tmp) == 0)
	{
		free(tmp);
		error();
	}
	return (tmp);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   perform.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 01:35:03 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/08 01:41:31 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include <limits.h>
#include "./../push_swap.h"

void	do_rotation(t_stack *a, t_stack *b, t_mov movs)
{
	int	i;

	i = 0;
	while (i < movs.ra)
	{
		rotate(a);
		i++;
	}
	i = 0;
	while (i < movs.rb)
	{
		rotate(b);
		i++;
	}
	i = 0;
	while (i < movs.rr)
	{
		double_rotate(a, b);
		i++;
	}
}

void	do_reverse_rotation(t_stack *a, t_stack *b, t_mov movs)
{
	int	i;

	i = 0;
	while (i < movs.rra)
	{
		reverse_rotate(a);
		i++;
	}
	i = 0;
	while (i < movs.rrb)
	{
		reverse_rotate(b);
		i++;
	}
	i = 0;
	while (i < movs.rrr)
	{
		double_reverse(a, b);
		i++;
	}
}

void	perform_rotations(t_stack *a, t_stack *b, t_mov movs)
{
	do_reverse_rotation(a, b, movs);
	do_rotation(a, b, movs);
	push(a, b);
}
#include "./../push_swap.h"

void	plan_and_move(int pos, t_stack *a, t_stack *b)
{
	t_mov	seq;
	int		target_a;

	target_a = target(*a, pos);
	seq = calculate_movs(a->top, b->top, target_a, pos);
	perform_rotations(a, b, seq);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   position.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/07 21:05:17 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/07 21:07:28 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

int	middle(int n)
{
	return ((n / 2) - (n % 2));
}

int	single_cost(int pos, int top, int middle)
{
	if (pos >= middle)
		return (top - pos);
	else
		return (pos + 1);
}

int	median(int top, int target_a)
{
	if (target_a >= middle(top))
		return (2);
	else
		return (1);
}

int	max(int a, int b)
{
	if (a > b)
		return (a);
	else
		return (b);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_three.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:14:49 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 16:40:21 by ranavarr         ###   ########.fr       */ /*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

/*
	returns the position of the biggest digit in an array, asumes there is no 
	repetition.
	on error: -1;
*/
int	biggest(int *arr, int top)
{
	int	i;
	int	big;
	int	big_pos;

	i = 0;
	big = INT_MIN;
	big_pos = -1;
	while (i <= top)
	{
		if (arr[i] > big)
		{
			big = arr[i];
			big_pos = i;
		}
		i++;
	}
	return (big_pos);
}

int	smallest(int *arr, int top)
{
	int	i;
	int	small;
	int	small_pos;

	i = 0;
	small = INT_MAX;
	small_pos = -1;
	while (i <= top)
	{
		if (arr[i] < small)
		{
			small = arr[i];
			small_pos = i;
		}
		i++;
	}
	return (small_pos);
}

void	sort_three(t_stack *a)
{
	if (a->arr[2] > a->arr[1])
		swap(a);
	if (a->arr[1] > a->arr[0])
		reverse_rotate(a);
	if (a->arr[2] > a->arr[1])
		swap(a);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_two.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:11:49 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 16:13:53 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

void	sort_two(t_stack *a)
{
	if (!is_sorted(*a))
		swap(a);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   target.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 03:32:42 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/07 23:00:08 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"
#include "stdio.h"

/*
	receives:
	t_stack a
	int n;
	returns: int position of the target
*/
int	target(t_stack a, int n)
{
	int	i;
	int	target_pos;
	int	small;

	target_pos = smallest(a.arr, a.top);
	small = INT_MAX;
	i = 0;
	while (i <= a.top)
	{
		if (a.arr[i] > n && small > a.arr[i])
		{
			small = a.arr[i];
			target_pos = i;
		}
		i++;
	}
	//ft_printf("n = %d, target= %d\n", n, a.arr[target_pos]);
	return (target_pos);
}
#include "./../push_swap.h"

void	move_all_but_three(t_stack *a, t_stack *b)
{
	while (a->top > 2)
		push(b, a);
}

void	turk(t_stack *a, t_stack *b)
{
	int	*cost;

	move_all_but_three(a, b);
	while (b->top >= 0 )
	{
		cost = calculate_cost(*a, *b);
		plan_and_move(smallest(cost, b->top), a, b);
	/*
		while (is_sorted(*a) == 0)
		{
			reverse_rotate(a);
		}
	*/
		free(cost);
	}


}
