/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/04 22:09:22 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/08 01:41:59 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PUSH_SWAP_H
# define PUSH_SWAP_H
# define OP_PUSH	10
# define OP_SWAP	20
# define OP_ROT		30
# define OP_REV		40
# define ID_A		1
# define ID_B		2
# define ID_BOTH	3
# include <stdlib.h>
# include <unistd.h>

/*
typedef struct s_pair
{
	struct	*s_stacka;
	struct	*s_stackb;
	char 	*movements;
}	t_pair;
*/

typedef struct s_movements
{
	int	ra;
	int	rra;
	int	rb;
	int	rrb;
	int	rrr;
	int	rr;
}	t_mov;

typedef struct s_targets
{
	int	*target;
	int	*cost;
	int	top;
}	t_cost;

typedef struct s_stack
{
	int		*arr;
	int		top;
	char	id;
}	t_stack;

//operations.c
char	swap(t_stack *stack);
char	rotate(t_stack *stack);
char	reverse_rotate(t_stack *stack);
char	push(t_stack *target, t_stack *source);

//double_operations.c
char	double_rotate(t_stack *a, t_stack *b);
char	double_swap(t_stack *a, t_stack *b);
char	double_reverse(t_stack *a, t_stack *b);
//is_sorted.c
int		is_sorted(t_stack stack);
//position.c
int		middle(int n);
int		single_cost(int pos, int top, int middle);
int		median(int top, int target_a);
int		max(int a, int b);
//cost.c
int		optimised_cost(int top_a, int top_b, int target_a, int target_b);
void	calculate_cost(t_stack a, t_cost *cost);
//index.c
int		biggest(int *tab, int top);
int		next(int *tab, int top, int prev);
int		indexate(int *original, int top);
//parse.c
int		*arrtoi(int argc, char *argv[]);
int		check_repetition(int top, int *tab);
int		*parse(int argc, char *argv[]);
//target.c
int		target(t_stack a, int n);
t_cost	calculate_targets(t_stack a, t_stack b);
//perform.c
int		smallest(int *tab, int top);
void	do_rotation(t_stack *a, t_stack *b, t_mov movs);
void	do_reverse_rotation(t_stack *a, t_stack *b, t_mov movs);
void	perform(t_stack *a, t_stack *b, t_mov movs);

#endif
NAME        := push_swap
CC          := cc
CFLAGS      := -Wall -Wextra -Werror -Iinclude

SRC_DIR     := src
OBJ_DIR     := obj

SRCS        := $(wildcard $(SRC_DIR)/*.c)
OBJS        := $(SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

# Default target
all: $(NAME)

# Link only if object files changed
$(NAME): $(OBJS)
	$(CC) $(CFLAGS) -o $@ $^

# Compile only modified files
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(OBJ_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Remove compiled files
clean:
	$(RM) -r $(OBJ_DIR)

fclean: clean
	$(RM) $(NAME)

# Clean + recompile
re: fclean all

.PHONY: all clean fclean re

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 00:55:22 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 01:05:33 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	main(int argc, char *argv[])
{
	return (push_swap(argc, argv));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   append_char.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 05:09:53 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 05:22:20 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cost.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 04:12:19 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/07 22:14:13 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"
/*
int	middle(int n)
{
	return ((n / 2) - (n % 2));
}

int	single_cost(int pos, int top, int middle)
{
	if (pos >= middle)
		return (top - pos);
	else
		return (pos++);
}

int	median(t_stack a, int ta)
{
	if (ta >= middle(a.top))
		return (2);
	else
		return (1);
}

int	max(int a, int b)
{
	if (a > b)
		return (a);
	else
		return (b);
}*/
/*
	when given a position in b and  a target postion in a
	it retuns the number of necessary operations needed to 
	move b into a
*/
int	optimised_cost(int top_a, int top_b, int target_a, int target_b)
{
	int	middle_a;
	int	middle_b;
	int	cost_a;
	int	cost_b;
	int	cost_total;

	middle_a = median(top_a, target_a);
	middle_b = median(top_b, target_b);
	cost_a = single_cost(target_a, top_a, middle_a);
	cost_b = single_cost(target_b, top_b, middle_b);
	if (middle_a == 1 && middle_b == 1 || middle_a == 2 && middle_b == 2)
		cost_total = max(cost_a, cost_b);
	else
		cost_total = cost_b + cost_a;
	return (cost_total);
}

/*
	when given a stack and the cost struct, it will calculate the
	cost of moving every b position to its a target and place those
	results in cost.cost
*/
void	calculate_cost(t_stack a, t_cost *cost)
{
	int	i;
	int	*total;

	total = malloc(sizeof(int) * (cost->top + 1));
	if (!total)
		return ;
	i = 0;
	while (i <= cost->top)
	{
		cost->cost[i] = optimised_cost(a.top, cost->top, cost->target[i], i);
		i++;
	}
}
/*
	calculates the necesary actions to move given position of the stack a
	 to the top and writes them into the movement structure accordingly
*/
void	determine_single_ops_a(t_mov *seq, int middle, int top, int pos)
{
	if (middle == 1)
		seq->ra = top = top - pos;
	else if (middle == 2)
		seq->rra = pos + 1;
}

/*
	calculates the necesary actions to move given position of the stack b
	 to the top and writes them into the movement structure accordingly
*/
void	determine_single_ops_b(t_mov *seq, int middle, int top, int pos)
{
	if (middle == 1)
		seq->rb = top = top - pos;
	else if (middle == 2)
		seq->rrb = pos + 1;
}

/*
	given single operations, (ra & rb or rra & rrb), edits the movement 
	structure to reduce the number of operations
*/
void	calculate_single_optimization(int *a, int *b, int *double_op)
{
	if (a == b)
	{
		double_op = a;
		a = 0;
		b = 0;
	}
	else if (a > b)
	{
		double_op = b;
		a = a - b;
		b = 0;
	}
	else if (b > a)
	{
		double_op = a;
		b = b - a;
		b = 0;
	}
}

void	optimise(t_mov *seq)
{
	if (seq->rb != 0 && seq->ra != 0)
		calculate_single_optimization(seq->ra, seq->rb, seq->rr);
	else if (seq->rb != 0 && seq->ra != 0)
		calculate_single_optimization(seq->rra, seq->rrb, seq->rrr);
}

/*
	when given a position in b and  a target postion in a
	it retuns the number of necessary operations needed to 
	move b into a
*/
t_mov	calculate_movs(int top_a, int top_b, int target_a, int target_b)
{
	t_mov	seq;
	int		middle_a;
	int		middle_b;

	seq.ra = 0
	seq.rra = 0
	seq.rb = 0
	seq.rrb = 0
	seq.rrr = 0;
	seq.rr = 0;
	determine_single_ops_a(&seq, 

}

t_cost	optimised_cost(int top_a, int top_b, int target_a, int target_b)
{
	int	middle_a;
	int	middle_b;
	int	cost_a;
	int	cost_b;
	int	cost_total;

	middle_a = median(top_a, target_a);
	middle_b = median(top_b, target_b);
	cost_a = single_cost(target_a, top_a, middle_a);
	cost_b = single_cost(target_b, top_b, middle_b);
	if (middle_a == 1 && middle_b == 1 )
	{
		
	}
	else if(middle_a == 2 && middle_b == 2)
		cost_total = max(cost_a, cost_b);
	else
		cost_total = cost_b + cost_a;
	return (cost_total);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   double_operations.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 03:03:20 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 03:08:50 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

char	double_rotate(t_stack *a, t_stack *b)
{
	rotate(a);
	rotate(b);
	return (OP_ROT + 3);
}

char	double_swap(t_stack *a, t_stack *b)
{
	swap(a);
	swap(b);
	return (OP_SWAP + 3);
}

char	double_reverse(t_stack *a, t_stack *b)
{
	reverse_rotate(a);
	reverse_rotate(b);
	return (OP_REV + 3);
}
#include <stdio.h>
#include <limits.h>
#include "./../push_swap.h"

/*
	retuns the position of the biggest number in an array
*/
int	biggest(int *tab, int top)
{
	int	i;
	int	max;
	int	max_pos;

	i = 0;
	max = INT_MIN;
	max_pos = -1;
	while (i <= top)
	{
		if (tab[i] > max)
		{
			max = tab[i];
			max_pos = i;
		}
		i++;
	}
	return (max_pos);
}

/*
	retuns the position of the number with the position right after the one
	given as int prev
*/
int	next(int *tab, int top, int prev)
{
	int	i;
	int	max;
	int	max_pos;

	i = 0;
	max = INT_MIN;
	max_pos = -1;
	while (i <= top)
	{
		if (tab[i] > max && tab[i] < prev)
		{
			max = tab[i];
			max_pos = i;
		}
		i++;
	}
	return (max_pos);
}

/*
	receives an array of numbers and creates a similar array
	where the numberical values of the original are replaced by their
	position were they ordered.
	arguments:
		- int original: stak to be converted;
		- int top: position of the last elemnt of the array
*/
int	*indexate(int *original, int top)
{
	int	i;
	int	pos;
	int	*indexate;

	indexate = malloc(sizeof(int) * (top + 1));
	if (!indexate)
		return (NULL);
	i = top;
	pos = biggest(original, top);
	indexate[pos] = i;
	while (i > 0)
	{
		pos = next(original, top, original[pos]);
		indexate[pos] = i;
		i--;
	}
	return (indexate);
}

void	index_stack(t_stack *a, int argc, int *tab)
{
	int	i;

	i = 1;
	a->top = argc - 2;
	a->arr = indexate(tab, argc - 2);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_empty.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/07 21:51:32 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/07 21:51:49 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_sorted.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 01:09:43 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 04:02:47 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

int	is_sorted(t_stack stack)
{
	int	i;

	i = stack.top;
	while (i > 0)
	{
		if (i > i - 1)
			return (0);
		i--;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operations.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 01:52:14 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 01:54:26 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

char	swap(t_stack *stack)
{
	int	tmp;
	int	top;

	top = stack->top;
	tmp = stack->arr[top];
	stack->arr[top] = stack->arr[top - 1];
	stack->arr[top - 1] = tmp;
	stack->top--;
	return (OP_SWAP + stack->id);
}

char	rotate(t_stack *stack)
{
	int	tmp;

	tmp = stack->arr[stack->top];
	ft_memmove(&stack->arr[1], &stack->arr[0], stack->top);
	stack->arr[0] = tmp;
	return (OP_ROT + stack->id);
}

char	reverse_rotate(t_stack *stack)
{
	int	tmp;

	tmp = stack->arr[0];
	ft_memmove(&stack->arr[0], &stack->arr[1], stack->top);
	stack->arr[stack->top] = tmp;
	return (OP_REV + stack->id);
}

char	push(t_stack *target, t_stack *source)
{
	target->id++;
	target->arr[target->top] = source->arr[source->top];
	source->top--;
	return (OP_PUSH + target->id);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 00:38:06 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/08 00:45:39 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

int	*arrtoi(int argc, char *argv[])
{
	int	i;
	int	*result;

	result = malloc(sizeof(int) * (argc - 1));
	if (!result)
		return (NULL);
	i = 1;
	while (i <= argc)
	{
		result[i] = ft_atoi(argv[i]);
		i++;
	}
}

/*
	0 = fail, there a repeated numbers
	1 = pass, no repetition
*/
int	check_repetition(int top, int *tab)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while (i <= top)
	{
		while (j <= top)
		{
			if (j != i && tab[i] == tab[j])
				return (0);
			j++;
		}
		i++;
	}
	return (1);
}

int	*parse(int argc, char *argv[])
{
	int	i;
	int	*tmp;

	if (argc <= 2)
		exit(0);
	tmp = arrtoi(argc, argv);
	i = 0;
	if (check_repetition(argc - 2, tmp) == 0)
	{
		free(tmp);
		exit(1);
	}
	return (tmp);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   perform.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 01:35:03 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/08 01:41:31 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include <limits.h>
#include "./../push_swap.h"

int	smallest(int *tab, int top)
{
	int	i;
	int	min;
	int	min_pos;

	i = 0;
	min = INT_MAX;
	min_pos = -1;
	while (i <= top)
	{
		if (tab[i] < top)
		{
			min = tab[i];
			min_pos = i;
		}
		i++;
	}
	return (min_pos);
}

/*
void	loop_rrr(t_stack *a, t_stack *b, int laps)
{
	int	i;

	i = 0;
	while (i < laps)
	{
		reverse_rotate(a);
		reverse_rotate(b);
		i++;
	}
}

void	loop_rr(t_stack *a, t_stack *b, int laps)
{
	int	i;

	i = 0;
	while (i < laps)
	{
		rotate(a);
		rotate(b);
		i++;
	}
}

int	calculate_movements(int top_a, int top_b, int target_a, int target_b)
{
	int	middle_a;
	int	middle_b;
	int	cost_a;
	int	cost_b;
	int	cost_total;

	middle_a = median(top_a, target_a);
	middle_b = median(top_b, target_b);
	cost_a = single_cost(target_a, top_a, middle_a);
	cost_b = single_cost(target_b, top_b, middle_b);
	if (middle_a == 1 && middle_b == 1)
	{
		cost_total = max(cost_a, cost_b);
	}
	else if (middle_a == 2 && middle_b == 2)
	else
		cost_total = cost_b + cost_a;
	return (cost_total);
}
*/

void	do_rotation(t_stack *a, t_stack *b, t_mov movs)
{
	int	i;

	i = 0;
	while (i < movs.ra)
	{
		rotate(a);
		i++;
	}
	i = 0;
	while (i < movs.rb)
	{
		rotate(b);
		i++;
	}
	i = 0;
	while (i < movs.rr)
	{
		rotate(a);
		rotate(b);
		i++;
	}
}

void	do_reverse_rotation(t_stack *a, t_stack *b, t_mov movs)
{
	int	i;

	i = 0;
	while (i < movs.rra)
	{
		reverse_rotate(a);
		i++;
	}
	i = 0;
	while (i < movs.rra)
	{
		reverse_rotate(b);
		i++;
	}
	i = 0;
	while (i < movs.rra)
	{
		reverse_rotate(b);
		reverse_rotate(a);
		i++;
	}
}

void	perform(t_stack *a, t_stack *b, t_mov movs)
{
	do_rotation(a, b, movs);
	do_reverse_rotation(a, b, movs);
	push(a, b);
}

/*
	i = 0;
	while (i < movs.ra)
	{
		rotate(a);
		i++;
	}
	i = 0;
	while (i < movs.ra)
	{
		rotate(a);
		i++;
	}
	i = 0;
	while (i < movs.ra)
	{
		rotate(a);
		i++;
	}
}d
*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   position.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/07 21:05:17 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/07 21:07:28 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

int	middle(int n)
{
	return ((n / 2) - (n % 2));
}

int	single_cost(int pos, int top, int middle)
{
	if (pos >= middle)
		return (top - pos);
	else
		return (pos++);
}

int	median(int top, int target_a)
{
	if (target_a >= middle(top))
		return (2);
	else
		return (1);
}

int	max(int a, int b)
{
	if (a > b)
		return (a);
	else
		return (b);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print_op.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 13:24:14 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 14:20:59 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

void	print_units(char c);
{
	int	tens;

	tens = c / 10;
	tens = tens * 10;

	if (tens = OP_PUSH)
		ft_putchar('p');
	else if (tens = OP_SWAP)
		ft_putchar('s');
	else if (tens = OP_ROT)
		ft_putchar('r');
	else if (tens = OP_REV)
		ft_printf("rr");
}

void	print_tens(char c);
{
	int	tens;
	int units;

	tens = c / 10;
	tens = tens * 10;
	units = c - tens;
	if 

}

void	print_op(char *queue)
{
	int	i;

	i = 0;
	while (queue
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/04 22:52:53 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/04 22:54:14 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	main(int argc, char *argv[])
{
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 13:22:27 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/08 01:42:46 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

void	turk(t_stack *a, t_stack *b)
{
	t_cost	costs;
	t_mov	instructions;

	while (a->top > 3)
		push(a, b);
	while (b->top > 0)
	{
		costs = calculate_targets(*a, *b);
		calculate_cost(*a, &costs);
		
		perform(a, b, instructions);
		
	}
}
#include "./../push_swap.h"

void	sort_five(t_stack a, t_stack b)
{
	while (!is_sorted(*a))
	{
		if 	
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_three.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:14:49 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 16:40:21 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

int	biggest(t_stack a)
{
	int	i;
	int	big;

	big = INT_MIN;
	while (a.arr[i])
	{
		if (a.arr[i] > big)
			big = i;
		i++;
	}
	return (big);
}

int	smallest(t_stack a)
{
	int	i;
	int	small;

	small = INT_MAX;
	while (a.arr[i])
	{
		if (a.arr[i] < small)
			small = i;
		i++;
	}
	return (small);
}

void	sort_three(t_stack *a)
{
	int	big;
	int	small;

	big = biggest(*a);
	small = smallest(*a);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_two.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 16:11:49 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/05 16:13:53 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./../push_swap.h"

void	sort_two(t_stack *a)
{
	if (!is_sorted(*a))
		swap(a);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   target.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ranavarr <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 03:32:42 by ranavarr          #+#    #+#             */
/*   Updated: 2025/08/07 23:00:08 by ranavarr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

int	target(t_stack a, int n)
{
	int	i;
	int	target;

	target = 0;
	i = a.top;
	while (i >= 0)
	{
		if (a.arr[i] > i && a.arr[i] < a.arr[target])
			target = i;
		i--;
	}
	return (target);
}

/*
	returns a structure that contains:
	target:	array that contains the target position for the number in its pos
	cost: cost to move it's corresponding positon to the top of a.
	top: position of the highest up value (copied from b.top)
*/
t_cost	calculate_targets(t_stack a, t_stack b)
{
	int		i;
	t_cost	cost;

	cost.target = malloc(sizeof(int) * (b.top + 1));
	if (!cost.target)
		return (cost);
	i = 0;
	cost.top = b.top;
	while (i <= b.top)
	{
		cost.target[i] = target(a, b.arr[i]);
		i++;
	}
	return (cost);
}
